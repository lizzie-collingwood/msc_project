import json
import ast
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
plt.style.use('ggplot')
plt.rcParams['mathtext.fontset'] = 'stix'
plt.rcParams['font.family'] = 'STIXGeneral'
import cmasher as cmr


class AnalyseJson:
    """Opens and extracts data and info from the json output of sw_energy.py."""
    column_dict = {
        1: {'ylab': 'Total mass (kg)'},
        2: {'ylab': 'Energy'},
        3: {'ylab': 'Absolute vorticity'},
        4: {'ylab': 'Total enstrophy'},
        5: {'ylab': 'Linear iterations'},
        6: {'ylab': 'Nonlinear iterations'},
        7: {'ylab': 'Execution time'}}
    leg_dict = {
        'poisson': {'rename': '', 'options': {'True': 'PI', 'False': 'IMR', 'Picard': 'Picard'}},
        'upwind': {'rename': '', 'options': {'True': 'Upwind', 'False': 'Average'}},
        'dt': {'rename': 'Time step (hours)'},
        'snes_rtol': {'rename': 'Nonlinear stopping criteration: relative residual norm'},
        'rtol': {'rename': 'Linear stopping criteration: relative residual norm'},
        'atol': {'rename': 'Linear stopping criteration: absolute residual norm'},
        'softsign': {'rename': '$a$ ='},
    }
    ignore_dict = ['base_level']

    def __init__(self, file=None):
        if file is not None:
            self.array, self.options = self.read_json(jsonfile=file)

    def read_json(self, jsonfile):
        """Read, load, and plot data held in JSON file: mass, energy, abs vorticity, and enstrophy."""
        # Load JSON file
        with open(jsonfile) as f:
            jsondata = json.load(f)

            # Extract the option information
            options = jsondata['options']

            # Extract the keys and values and concatenate
            data = jsondata['data']

        times = np.asarray(list(data), dtype=float) / (3600*24)
        vals = np.asarray(list(data.values()), dtype=float)
        return np.r_['1,2,0', times, vals], options

    def extract(self, kwargs):
        """Extract the data and options info from json files."""
        arrs, ops = {}, []
        for key, value in kwargs.items():
            arr, op = self.read_json(jsonfile=value)
            arrs.update({key: arr})
            ops.append(ast.literal_eval(op))

        # Combine the option data into one dict.
        ops = {k: [d[k] for d in ops] for k in ops[0]}
        return arrs, ops

    @staticmethod
    def find_test_parameters(leg_dict, ops, ignore_dict):
        """
        Finds the test parameters given options dict.
        :param ops: dict, contains the parser arg output from sw_energy.py.
        :return out: outputs the labels of the datasets in terms of the test parameter(s).
        """
        out = []
        for k, vals in ops.items():
            if k in ignore_dict: continue
            if len(set(vals))>1:
                labs = list(map(str, vals))
                K = k + ': '
                try:
                    K = leg_dict[k]['rename'] + ' '
                    try:
                        labs = [leg_dict[k]['options'][l] for l in labs]
                    except: pass
                except: pass

                if len(out)==0:
                    out = [K+l for l in labs]
                else:
                    out = [out[i]+', '+K+labs[i] for i in range(len(labs))]
        
        if len(out)==0: out = [' ']
        return out

    @staticmethod
    def normalise(slice):
        """Normalise the data slice according to the initial value."""
        return (slice - slice[0]) / slice[0]

    def multiplot(self, normalise=False, semilog=False, cumsum=False, cmap='viridis', colnum=1, **kwargs):
        """
        Plot multiple json file data.
        :param kwargs: any number of strings describing path to json files.
        :param normalise: bool, whether to normalise the data according to initial value.
        :param semilog: bool, whether to scale the y axis using semilog.
        :param colnum: int, identifies which column of the output array to plot.
        """
        # Set the colour scheme
        colours = cmr.take_cmap_colors(cmap, len(kwargs), return_fmt='hex')

        # Extract data, options and labels from json files.
        arrs, ops = self.extract(kwargs)
        labels = self.find_test_parameters(self.leg_dict, ops, self.ignore_dict)
        # labels = ['Original','Simplified solver']

        # Plot the json data
        plt.figure()
        for i, (_, arr) in enumerate(arrs.items()):
            if normalise: column = self.normalise(arr[1:, colnum])
            else: column = arr[1:, colnum]
            if cumsum: column = np.cumsum(column)
            if semilog: plt.semilogy(arr[1:, 0], np.abs(column), label=labels[i], color=colours[i])
            else: plt.plot(arr[1:, 0], column, label=labels[i], color=colours[i])
            
        # Axes labels
        plt.xlabel('Time (days)')
        if normalise: plt.ylabel('Relative error: '+self.column_dict[colnum]['ylab'])
        else: plt.ylabel(self.column_dict[colnum]['ylab'])

        # Xtick labels + legend
        dmax = max(ops['dmax'])
        plt.xticks(np.arange(dmax+1))
        if len(kwargs)>1: plt.legend()
        plt.show()

    def perinf(self, **kwargs):
        """
        Print performance information and measurements.
        """
        # Extract data, options and labels from json files.
        arrs, ops = self.extract(kwargs)
        labels = self.find_test_parameters(self.leg_dict, ops, self.ignore_dict)
        cols = [5, 6, 7]
        
        # Extract and compute relevant performance measures.
        totdata = {}
        for i, (j, arr) in enumerate(arrs.items()):
            # Get data about totals
            tots = [np.sum(arr[:, i]) for i in cols]
            tots.append(arr.shape[0])
            totdata.update({j: tots})
        
        # Combine data into a dataframe.
        data = np.array([totdata[i] for i in totdata.keys()])
        columns = [self.column_dict[i]['ylab'] for i in cols]
        columns.append('No. timesteps')
        df = pd.DataFrame(data, index=labels, columns=columns)

        # Add extra columns
        df['Avg. linear its / nonlinear its'] = df.iloc[:, 0] / df.iloc[:, 1]
        df['Avg. linear its / timestep'] = df.iloc[:, 0] / df.iloc[:, 2]
        df['Avg. nonlinear its / timestep'] = df.iloc[:, 1] / df.iloc[:, 2]

        # Write options to text file.
        df.round(2).to_csv('dataperinf.txt')

        print(df.round(2))

    @staticmethod
    def softsignplot():

        # Set the colour scheme
        colours = cmr.take_cmap_colors('coolwarm', 3, return_fmt='hex')

        # Plot the sign and soft sign
        plt.figure()
        xx = np.arange(-7,8,0.01)
        plt.plot(xx, xx/np.sqrt(xx**2 + 1), color=colours[0], label='Soft sign')
        plt.plot(xx, np.sign(xx), color=colours[-1], label='Sign')

        # Formatting
        plt.xticks(np.arange(-7,8), labels=[])
        plt.xlim([-7,7])
        plt.hlines(y=0, xmin=-7, xmax=7, color='darkgray')
        plt.legend()
        plt.show()
        

# Provide path to JSON files
f1 = '/Users/lizziecollingwood/MSc./proj/simulations/w5/ref2/PI/upwind/w5aug.json'
f1a = '/Users/lizziecollingwood/MSc./proj/simulations/w5/ref2/PI/upwind/NEWENERGY/w5aug.json'
f2 = '/Users/lizziecollingwood/MSc./proj/simulations/w5/ref2/IMR/upwind/w5aug.json'
f3 = '/Users/lizziecollingwood/MSc./proj/simulations/w5/ref2/IMR/avg/w5aug.json'
f4 = '/Users/lizziecollingwood/MSc./proj/simulations/w5/ref2/PI/avg/w5aug.json'
f5 = '/Users/lizziecollingwood/MSc./proj/simulations/w5/ref2/PI/avg/atoln12/w5aug.json'
f6 = '/Users/lizziecollingwood/MSc./proj/simulations/w5/ref4/PI/dt1/avg/w5aug.json'
f7 = '/Users/lizziecollingwood/MSc./proj/simulations/w5/ref4/PI/dt1/upwind/a0/w5aug.json'
f8 = '/Users/lizziecollingwood/MSc./proj/simulations/w5/ref4/PI/dt1/upwind/a20/w5aug.json'
f9 = '/Users/lizziecollingwood/MSc./proj/simulations/w5/ref4/PI/dt1/upwind/a2/w5aug.json'
f10 = '/Users/lizziecollingwood/MSc./proj/simulations/w5/ref4/PI/dt1/upwind/a40/w5aug.json'
f11 = '/Users/lizziecollingwood/MSc./proj/simulations/w5/ref4/PI/dt1/upwind/a80/w5aug.json'
f12 = '/Users/lizziecollingwood/MSc./proj/simulations/w5/ref4/PI/dt1/upwind/a160/w5aug.json'
f13 = '/Users/lizziecollingwood/MSc./proj/simulations/w5/ref5/PI/avg/w5aug.json'
f14 = '/Users/lizziecollingwood/MSc./proj/simulations/w5/ref5/IMR/avg/w5aug.json'
f15 = '/Users/lizziecollingwood/MSc./proj/simulations/w5/ref5/PI/upwind/w5aug.json'
f16 = '/Users/lizziecollingwood/MSc./proj/simulations/w5/ref5/IMR/upwind/w5aug.json'
f17a = '/Users/lizziecollingwood/MSc./proj/simulations/w5/ref2/Picard/upwind/w5aug.json'
f17b = '/Users/lizziecollingwood/MSc./proj/simulations/w5/ref2/Picard/upwind/newoptions/w5aug.json'
f20 = '/Users/lizziecollingwood/MSc./proj/simulations/w5/ref4/PI/upwind/w5aug.json'
f21 = '/Users/lizziecollingwood/MSc./proj/simulations/w5/ref4/PI/avg/w5aug.json'
f22 = '/Users/lizziecollingwood/MSc./proj/simulations/w5/ref4/IMR/upwind/w5aug.json'
f23 = '/Users/lizziecollingwood/MSc./proj/simulations/w5/ref4/IMR/avg/w5aug.json'
f24 = '/Users/lizziecollingwood/MSc./proj/simulations/w5/ref2/PI/upwind/NEWENERGY/NEWGRAVITY/w5aug.json'
f25 = '/Users/lizziecollingwood/MSc./proj/simulations/w5/ref4/PI/upwind/NEWGRAVITY/w5aug.json'
f26 = '/Users/lizziecollingwood/MSc./proj/simulations/w5/ref1/testref4/newparams/w5aug.json'
f27 = '/Users/lizziecollingwood/MSc./proj/simulations/w5/ref4/PI/upwind/a20/w5aug.json'

# Initialise class and implement method
aj = AnalyseJson()

# ======= Changing g
# aj.multiplot(j1=f20, j2=f25, colnum=2, normalise=True, semilog=True, cmap='coolwarm')

# ======= Eliminating D1
# aj.multiplot(j1=f7, j2=f26, colnum=2, normalise=True, semilog=True, cmap='coolwarm')
# aj.perinf(j3=f7, j2=f26)

# ======= Upwind softsign values
# aj.multiplot(j3=f7, j2=f9, j1=f8, j4=f10, j6=f11, j7=f12, j5=f6, colnum=2, normalise=True, semilog=True, cmap='coolwarm')
# aj.multiplot(j3=f20, j5=f27, colnum=2, normalise=True, semilog=True, cmap='coolwarm')

# ======= Ref4
# aj.multiplot(j1=f20, j2=f21, j3=f22, j4=f23, colnum=2, normalise=True, semilog=True, cmap='coolwarm')
# aj.multiplot(j1=f20, j2=f21, colnum=2, normalise=True, semilog=True, cmap='coolwarm')

# ======= Ref5
# aj.multiplot(j1=f15, j3=f16, colnum=2, normalise=True, semilog=True, cmap='coolwarm')
# aj.multiplot(j1=f15, j2=f13, j3=f16, j4=f14, colnum=2, normalise=True, semilog=True, cmap='coolwarm')
# aj.perinf(j3=f15, j2=f16) # IMR v PI
aj.perinf(j3=f15, j2=f13) # upwind v avg

# ======= Ref4 vs Ref5
# aj.multiplot(j1=f20, j2=f15, colnum=2, normalise=True, semilog=True, cmap='coolwarm')

# ======= Picard vs IMR vs PI
# aj.multiplot(j1=f1a, j2=f2, j4=f17a, j5=f17b, colnum=2, normalise=True, semilog=True, cmap='coolwarm')
# aj.multiplot(j1=f1a, j2=f2, j3=f16, j4=f17, colnum=7, normalise=False, semilog=False, cmap='coolwarm')

# ======= Tightening tolerances
# aj.multiplot(j1=f7, j2=f20, colnum=2, normalise=True, semilog=True, cmap='coolwarm')

# ======= Upwind vs avg
# aj.multiplot(j3=f13, j2=f15, colnum=4, normalise=True, semilog=True, cmap='coolwarm')




# ====== COLOURMAPS
# seismic
# winter
# inferno
# cool
# plasma
# Set2
# ocean / gist_earth / 
